package com.example.cloudant.app;

import java.util.List;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.ektorp.DocumentNotFoundException;
import org.ektorp.UpdateConflictException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.support.SpringBootServletInitializer;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import com.example.cloudant.app.entity.Account;
import com.example.cloudant.app.entity.AccountRepository;
import com.example.cloudant.app.error.ApplicationError;

/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'pinki' at '11/24/16 11:48 AM' with Gradle 2.13
 *
 * @author pinki, @date 11/24/16 11:48 AM
 */
@SpringBootApplication
@RestController
@RequestMapping("/account")
public class AccountCloudantApp extends SpringBootServletInitializer {

    private static Class<AccountCloudantApp> applicationClass = AccountCloudantApp.class;

    public static void main(String[] args) {
        SpringApplication.run(AccountCloudantApp.class, args);
    }




    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(applicationClass);
    }

    @Autowired
    private AccountRepository repository;

    @RequestMapping(method = RequestMethod.GET, produces = "application/json")
    public ResponseEntity<?> getAll() {
        List<Account> allAccounts = repository.getAll();
        if (allAccounts == null || allAccounts.isEmpty())
            return new ResponseEntity<ApplicationError>(
                    new ApplicationError(HttpStatus.NOT_FOUND.value(), "no documents found"), HttpStatus.NOT_FOUND);
        return new ResponseEntity<List<Account>>(allAccounts, HttpStatus.OK);
    }

    @RequestMapping(value = "{id}", method = RequestMethod.GET, produces = "application/json")
    public ResponseEntity<?> getById(@PathVariable String id) {
        Account account = null;
        try {
            account = repository.get(id);
        } catch (DocumentNotFoundException ex) {
            return new ResponseEntity<ApplicationError>(
                    new ApplicationError(HttpStatus.NOT_FOUND.value(), "specified customerID does not exist"),
                    HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<Account>(account, HttpStatus.OK);
    }

    @RequestMapping(method = RequestMethod.POST, consumes = "application/json")
    public ResponseEntity<?> create(@RequestBody Account acc) {
        try {
            repository.add(acc);
        } catch (UpdateConflictException ex) {
            return new ResponseEntity<ApplicationError>(new ApplicationError(HttpStatus.BAD_REQUEST.value(),
                    "update conflicted, add was aborted. Please check your payload"), HttpStatus.BAD_REQUEST);
        }
        return new ResponseEntity<Account>(acc, HttpStatus.CREATED);
    }

    @RequestMapping(method = RequestMethod.DELETE, value = "{id}")
    public ResponseEntity<?> delete(@PathVariable String id) {
        Account account = null;
        try {
            account = repository.get(id);
        } catch (DocumentNotFoundException ex) {
            return new ResponseEntity<ApplicationError>(
                    new ApplicationError(HttpStatus.NOT_FOUND.value(), "ID to be deleted not found"),
                    HttpStatus.NOT_FOUND);
        }
        repository.remove(repository.get(id));
        return new ResponseEntity<HttpStatus>(HttpStatus.OK);
    }

    @RequestMapping(method = RequestMethod.PUT, value = "{id}", consumes = "application/json")
    public ResponseEntity<?> update(@RequestBody Account acc, @PathVariable String id) {
        Account account = null;
        try {
            account = repository.get(id);
        } catch (DocumentNotFoundException ex) {
            return new ResponseEntity<ApplicationError>(
                    new ApplicationError(HttpStatus.NOT_FOUND.value(), "document to be updated not found"),
                    HttpStatus.NOT_FOUND);
        }

        account.setUserName(acc.getUserName());
        account.setAccountStatus(acc.getAccountStatus());
        account.setAccountType(acc.getAccountType());
        account.setAddress(acc.getAddress());
        account.setCustomerId(acc.getCustomerId());
        account.setMobileNumber(acc.getMobileNumber());
      repository.update(account);
        return new ResponseEntity<Account>(acc, HttpStatus.OK);
    }




}

